# java并发应用集合

> 阻塞式集合： 添加或者移除数据的方法，当集合已经满或者为空时，被调用的添加或者移除方法就不能立即执行，那么调用这个方法的线程将被阻塞，一直到该方法可以被成功执行

> 非阻塞式集合： 添加或者移除数据的方法，如果方法不能被立即执行，则返回空或者抛出异常，但是调用这个方法线程不会被调用

1. 非阻塞式列表：ConcurrentLinkedDeque 类
2. 阻塞式列表: LinkedBlockingDeque 类
3. 用户数据生成和消费的阻塞式列表对应的实现类 LinkedTransferQueue 类
4. 按优先级排序的阻塞式列表对应的实现类 PriorityBlockingQueue 类
5. 带有延迟列表元素的阻塞式列表的实现类 Delayqueue 类
6. 非阻塞式可遍历映射对应的实现类 ConcurrentSkipListMap 类
7. 随机数字对应的实现类 ThreadLocalRandom 类                         
8. 原子变量对应的实现类 AtomicLong 和 AtomicIntegerArray 类

## 原子变量 提供单个变量上的原子操作
> 在程序编译的过程中，java代码中的每一个变量，每一个操作都会被转换为机器可以理解的指令，例如：当一个变量赋值时，在java代码中只使用了一个指令，但是在编译的过程中，指令被转换为jvm中
的不同指令，当多个线程共享同一变量时，就会发生数据不一致的错误，为了避免这个错误，java中引入了原子变量:

> 当一个线程对原子变量操作时，如果其他线程也试图对同一原子变量操作，原子变量的实现类提供了一套机制来检测操作是否在一步之内完成。一般来说这个操作先获取变量值，然后本地改变变量值，然后
用这个改变的值去替换之前的值，如果之前的值没有被其他线程改变，就可以执行这个替换操作，这种操作成为CAS原子操作

> 原子操作不适用锁或者其他同步机制保护对其值得并发访问，所有操作都是基于CAS原子操作，保证了多线程在同一时间操作同一个原子变量而不会产生数据不一致的问题，并且它的性能优于使用同步机制保护的普通变量


